#include "stm32f4xx.h" 
#include "mpu9250.h"
#include "dmp.h"
#include "string.h"
#include "extra_math.h"
#include "spi.h"
#include "dma.h"


#define min(a,b) ((a<b)?a:b)
void Delay_ms(uint16_t ms);
void Delay_us(uint16_t us);

#define MPU_READ_DATA_SIZE 13
uint8_t MPU_DMA_tx[MPU_READ_DATA_SIZE] = {READ_COMMAND | FIFO_R_W};
uint8_t MPU_DMA_rx[MPU_READ_DATA_SIZE];

float accel[3];
float temp;
float angleRate[3];
float magField[3];

float mag_sens_adj[3];

uint8_t dmp_on = 0;

uint8_t meas1 = 1;
uint8_t process = 0;
extern float w1[3];
extern float w2[3];
extern float v1[3];
extern float v2[3];

#define MPU_MAX_DEVICES 1

MPU_Regs regArray[MPU_MAX_DEVICES];
HW hwArray[MPU_MAX_DEVICES];
MPU_Test testArray[MPU_MAX_DEVICES];
MPU_State gyroArray[MPU_MAX_DEVICES];

MPU_Regs *reg;
HW *hw;
MPU_Test *test;
MPU_State *st;
static int deviceIndex = 0;

static int reg_int_cb(MPU_IntParams *int_param) {
    int_param->active_low = 0;
    int_param->pin = 1;
    return 0;
}

#ifdef AK89xx_SECONDARY
static int setup_compass(void);
#define MAX_COMPASS_SAMPLE_RATE (100)
#endif

int MPU_SelectDevice(int device) {
  if ((device < 0) || (device >= MPU_MAX_DEVICES))
    return -1;

  deviceIndex = device;
  reg = regArray + device;
  hw = hwArray + device;
  test = testArray + device;
  st = gyroArray + device;
  return 0;
}

void MPU_InitStructures() {
    reg->who_am_i         = WHO_AM_I;
    reg->rate_div         = SMPLRT_DIV;
    reg->lpf              = CONFIG;
    reg->prod_id          = 0x0C;
    reg->user_ctrl        = USER_CTRL;
    reg->fifo_en          = FIFO_EN;
    reg->gyro_cfg         = GYRO_CONFIG;
    reg->accel_cfg        = ACCEL_CONFIG;
    reg->accel_cfg2       = ACCEL_CONFIG2;
    reg->lp_accel_odr     = LP_ACCEL_ODR;
    reg->motion_thr       = WOM_THR;
    reg->motion_dur       = 0x20;
    reg->fifo_count_h     = FIFO_COUNTH;
    reg->fifo_r_w         = FIFO_R_W;
    reg->raw_gyro         = GYRO_XOUT_H;
    reg->raw_accel        = ACCEL_XOUT_H;
    reg->temp             = TEMP_OUT_H;
    reg->int_enable       = INT_ENABLE;
    reg->dmp_int_status   = 0x39;
    reg->int_status       = INT_STATUS;
    reg->accel_intel      = MOT_DETECT_CTRL;
    reg->pwr_mgmt_1       = PWR_MGMT_1;
    reg->pwr_mgmt_2       = PWR_MGMT_2;
    reg->int_pin_cfg      = INT_PIN_CFG;
    reg->mem_r_w          = MEM_R_W;
    reg->accel_offs       = XA_OFFSET_H;
    reg->i2c_mst          = I2C_MST_CTRL;
    reg->bank_sel         = BANK_SEL;
    reg->mem_start_addr   = 0x6E;
    reg->prgm_start_h     = PRGM_START_H;
#ifdef AK89xx_SECONDARY
    reg->raw_compass      = EXT_SENS_DATA_00;
    reg->yg_offs_tc       = YG_OFFSET_H;
    reg->s0_addr          = I2C_SLV0_ADDR;
    reg->s0_reg           = I2C_SLV0_REG;
    reg->s0_ctrl          = I2C_SLV0_CTRL;
    reg->s1_addr          = I2C_SLV1_ADDR;
    reg->s1_reg           = I2C_SLV1_REG;
    reg->s1_ctrl          = I2C_SLV1_CTRL;
    reg->s4_ctrl          = I2C_SLV4_CTRL;
    reg->s0_do            = I2C_SLV0_DO;
    reg->s1_do            = I2C_SLV1_DO;
    reg->i2c_delay_ctrl   = I2C_MST_DELAY_CTRL;
#endif
    switch (deviceIndex) {
      case 0:
        hw->addr = 0x68;
        break;

      case 1:
        hw->addr = 0x69;
        break;
    }
    hw->max_fifo          = 1024;
    hw->num_reg           = 128;
    hw->temp_sens         = 321;
    hw->temp_offset       = 0;
    hw->bank_size         = 256;
#if defined AK89xx_SECONDARY
    hw->compass_fsr      = AK89xx_FSR;
#endif

    test->gyro_sens      = 32768/250;
    test->accel_sens     = 32768/16;
    test->reg_rate_div   = 0;    /* 1kHz. */
    test->reg_lpf        = 1;    /* 188Hz. */
    test->reg_gyro_fsr   = 0;    /* 250dps. */
    test->reg_accel_fsr  = 0x18; /* 16g. */
    test->wait_ms        = 50;
    test->packet_thresh  = 5;    /* 5% */
    test->min_dps        = 10.f;
    test->max_dps        = 105.f;
    test->max_gyro_var   = 0.14f;
    test->min_g          = 0.3f;
    test->max_g          = 0.95f;
    test->max_accel_var  = 0.14f;

    st->reg = reg;
    st->hw = hw;
    st->test = test;
};

// 0 if check passed
int MPU_WriteByteAndCheck(uint8_t address, uint8_t data) {
    uint8_t test;
    MPU_WriteByte(address, data);
    test = MPU_ReadByte(address);
    return (test != data);
}

void MPU_MemWrite(uint16_t addr, uint8_t *data, uint16_t size) {
    uint8_t tmp[2];
    tmp[0] = (uint8_t)(addr >> 8);
    tmp[1] = (uint8_t)(addr & 0xff);
    MPU_Write(BANK_SEL, tmp, 2);
    MPU_Write(MEM_R_W, data, size);
}

void MPU_MemRead(uint16_t addr, uint8_t *data, uint16_t size) {
    uint8_t tmp[2];
    tmp[0] = (uint8_t)(addr >> 8);
    tmp[1] = (uint8_t)(addr & 0xff);
    MPU_Write(BANK_SEL, tmp, 2);
    MPU_Read(MEM_R_W, data, size);
}

int MPU_Init(MPU_IntParams *int_param) {
    uint8_t data[6], rev;
    int errCode;

    /* Reset device. */
    MPU_WriteByte(st->reg->pwr_mgmt_1, BIT_RESET);
    Delay_ms(100);

    /* Wake up chip. */
    MPU_WriteByte(st->reg->pwr_mgmt_1, 0x00);

#if defined MPU6050
    /* Check product revision. */
    MPU_Read(st->reg->accel_offs, data, 6);
    rev = ((data[5] & 0x01) << 2) | ((data[3] & 0x01) << 1) |
        (data[1] & 0x01);

    if (rev) {
        /* Congrats, these parts are better. */
        if (rev == 1)
            st->chip_cfg.accel_half = 1;
        else if (rev == 2)
            st->chip_cfg.accel_half = 0;
        else {
            return -4;
        }
    } else {
        MPU_ReadByte(st->reg->prod_id, &data[0]);
        rev = data[0] & 0x0F;
        if (!rev) {
            return -6;
        } else if (rev == 4) {
            st->chip_cfg.accel_half = 1;
        } else
            st->chip_cfg.accel_half = 0;
    }
#elif defined MPU6500
#define MPU6500_MEM_REV_ADDR    (0x17)
    MPU_MemRead(MPU6500_MEM_REV_ADDR, &rev, 1);
    if (rev == 0x1)
        st->chip_cfg.accel_half = 0;
    else {
        return -8;
    }

    /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
     * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
     */
    data[0] = ;
    MPU_WriteByte(st->reg->accel_cfg2, 1, BIT_FIFO_SIZE_1024 | 0x8);
#endif

    /* Set to invalid values to ensure no I2C writes are skipped. */
    st->chip_cfg.sensors = 0xFF;
    st->chip_cfg.gyro_fsr = 0xFF;
    st->chip_cfg.accel_fsr = 0xFF;
    st->chip_cfg.lpf = 0xFF;
    st->chip_cfg.sample_rate = 0xFFFF;
    st->chip_cfg.fifo_enable = 0xFF;
    st->chip_cfg.bypass_mode = 0xFF;
#ifdef AK89xx_SECONDARY
    st->chip_cfg.compass_sample_rate = 0xFFFF;
#endif
    /* mpu_set_sensors always preserves this setting. */
    st->chip_cfg.clk_src = INV_CLK_PLL;
    /* Handled in next call to mpu_set_bypass. */
    st->chip_cfg.active_low_int = 0;
    st->chip_cfg.latched_int = 1;
    st->chip_cfg.int_motion_only = 0;
    st->chip_cfg.lp_accel_mode = 0;
    memset(&st->chip_cfg.cache, 0, sizeof(st->chip_cfg.cache));
    st->chip_cfg.dmp_on = 0;
    st->chip_cfg.dmp_loaded = 0;
    st->chip_cfg.dmp_sample_rate = 0;

    if (MPU_SetGyroFsr(250))
        return -10;
    if (MPU_SetAccelFsr(16))
        return -11;
    if (MPU_SetLPF(42))
        return -12;
    if (MPU_SetSampleRate(50))
        return -13;
    if (MPU_ConfigureFIFO(0))
        return -14;

    if (int_param)
        reg_int_cb(int_param);

#ifdef AK89xx_SECONDARY
    errCode = setup_compass();
    if (errCode != 0) {
    }
    if (MPU_SetCompassSampleRate(10))
        return -15;
#else
    /* Already disabled by setup_compass. */
    if (MPU_SetBypass(0))
        return -16;
#endif

    MPU_SetSensors(0);
    return 0;
}

int MPU_SetGyroFsr(uint16_t fsr) {
    uint8_t data;

    if (!(st->chip_cfg.sensors))
        return -1;

    switch (fsr) {
    case 250:
        data = INV_FSR_250DPS << 3;
        break;
    case 500:
        data = INV_FSR_500DPS << 3;
        break;
    case 1000:
        data = INV_FSR_1000DPS << 3;
        break;
    case 2000:
        data = INV_FSR_2000DPS << 3;
        break;
    default:
        return -2;
    }

    if (st->chip_cfg.gyro_fsr == (data >> 3))
        return 0;
    if (MPU_WriteByteAndCheck(st->reg->gyro_cfg, data)) {
        return -3;
    }
    
    st->chip_cfg.gyro_fsr = data >> 3;
    return 0;
}

int MPU_SetAccelFsr(uint16_t fsr) {
    uint8_t data;

    if (!(st->chip_cfg.sensors))
        return -1;

    switch (fsr) {
    case 2:
        data = INV_FSR_2G << 3;
        break;
    case 4:
        data = INV_FSR_4G << 3;
        break;
    case 8:
        data = INV_FSR_8G << 3;
        break;
    case 16:
        data = INV_FSR_16G << 3;
        break;
    default:
        return -2;
    }

    if (st->chip_cfg.accel_fsr == (data >> 3))
        return 0;
    if (MPU_WriteByteAndCheck(st->reg->accel_cfg, data)) {
        return -3;
    }
    
    st->chip_cfg.accel_fsr = data >> 3;
    return 0;
}

/**
 *  @brief      Set digital low pass filter.
 *  The following LPF settings are supported: 188, 98, 42, 20, 10, 5.
 *  @param[in]  lpf Desired LPF setting.
 *  @return     0 if successful.
 */
int MPU_SetLPF(uint16_t lpf) {
    uint8_t data;
    if (!(st->chip_cfg.sensors))
        return -1;

    if (lpf >= 188)
        data = INV_FILTER_188HZ;
    else if (lpf >= 98)
        data = INV_FILTER_98HZ;
    else if (lpf >= 42)
        data = INV_FILTER_42HZ;
    else if (lpf >= 20)
        data = INV_FILTER_20HZ;
    else if (lpf >= 10)
        data = INV_FILTER_10HZ;
    else
        data = INV_FILTER_5HZ;

    if (st->chip_cfg.lpf == data)
        return 0;
    if (MPU_WriteByteAndCheck(st->reg->lpf, data)) {
        return -3;
    }
    
    st->chip_cfg.lpf = data;
    return 0;
}

/**
 *  @brief      Set sampling rate.
 *  Sampling rate must be between 4Hz and 1kHz.
 *  @param[in]  rate    Desired sampling rate (Hz).
 *  @return     0 if successful.
 */
int MPU_SetSampleRate(uint16_t rate) {
    uint8_t data;

    if (!(st->chip_cfg.sensors))
        return -1;

    if (st->chip_cfg.dmp_on)
        return -1;
    else {
        if (st->chip_cfg.lp_accel_mode) {
            if (rate && (rate <= 40)) {
                /* Just stay in low-power accel mode. */
                MPU_LowPowerAccelMode(rate);
                return 0;
            }
            /* Requested rate exceeds the allowed frequencies in LP accel mode,
             * switch back to full-power mode.
             */
            MPU_LowPowerAccelMode(0);
        }
        if (rate < 4)
            rate = 4;
        else if (rate > 1000)
            rate = 1000;

        data = 1000 / rate - 1;
        if (MPU_WriteByteAndCheck(st->reg->rate_div, data)) {
            return -3;
        }
        
        st->chip_cfg.sample_rate = 1000 / (1 + data);

#ifdef AK89xx_SECONDARY
        MPU_SetCompassSampleRate(min(st->chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
#endif

        /* Automatically set LPF to 1/2 sampling rate. */
        MPU_SetLPF(st->chip_cfg.sample_rate >> 1);
        return 0;
    }
}

/**
 *  @brief      Enter low-power accel-only mode.
 *  In low-power accel mode, the chip goes to sleep and only wakes up to sample
 *  the accelerometer at one of the following frequencies:
 *  \n MPU6050: 1.25Hz, 5Hz, 20Hz, 40Hz
 *  \n MPU6500: 1.25Hz, 2.5Hz, 5Hz, 10Hz, 20Hz, 40Hz, 80Hz, 160Hz, 320Hz, 640Hz
 *  \n If the requested rate is not one listed above, the device will be set to
 *  the next highest rate. Requesting a rate above the maximum supported
 *  frequency will result in an error.
 *  \n To select a fractional wake-up frequency, round down the value passed to
 *  @e rate.
 *  @param[in]  rate        Minimum sampling rate, or zero to disable LP
 *                          accel mode.
 *  @return     0 if successful.
 */
int MPU_LowPowerAccelMode(uint8_t rate) {
    uint8_t tmp[2];

    if (rate > 40)
        return -1;

    if (!rate) {
        MPU_SetIntLatched(0);
        tmp[0] = 0;
        tmp[1] = BIT_STBY_XYZG;
        MPU_Write(st->reg->pwr_mgmt_1, tmp, 2);
        st->chip_cfg.lp_accel_mode = 0;
        return 0;
    }
    /* For LP accel, we automatically configure the hardware to produce latched
     * interrupts. In LP accel mode, the hardware cycles into sleep mode before
     * it gets a chance to deassert the interrupt pin; therefore, we shift this
     * responsibility over to the MCU.
     *
     * Any register read will clear the interrupt.
     */
    MPU_SetIntLatched(1);
#if defined MPU6050
    tmp[0] = BIT_LPA_CYCLE;
    if (rate == 1) {
        tmp[1] = INV_LPA_1_25HZ;
        mpu_set_lpf(5);
    } else if (rate <= 5) {
        tmp[1] = INV_LPA_5HZ;
        mpu_set_lpf(5);
    } else if (rate <= 20) {
        tmp[1] = INV_LPA_20HZ;
        mpu_set_lpf(10);
    } else {
        tmp[1] = INV_LPA_40HZ;
        mpu_set_lpf(20);
    }
    tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
    if (i2c_write(st->hw->addr, st->reg->pwr_mgmt_1, 2, tmp))
        return -1;
#elif defined MPU6500
    /* Set wake frequency. */
    if (rate == 1)
        tmp[0] = INV_LPA_1_25HZ;
    else if (rate == 2)
        tmp[0] = INV_LPA_2_5HZ;
    else if (rate <= 5)
        tmp[0] = INV_LPA_5HZ;
    else if (rate <= 10)
        tmp[0] = INV_LPA_10HZ;
    else if (rate <= 20)
        tmp[0] = INV_LPA_20HZ;
    else if (rate <= 40)
        tmp[0] = INV_LPA_40HZ;
    else if (rate <= 80)
        tmp[0] = INV_LPA_80HZ;
    else if (rate <= 160)
        tmp[0] = INV_LPA_160HZ;
    else if (rate <= 320)
        tmp[0] = INV_LPA_320HZ;
    else
        tmp[0] = INV_LPA_640HZ;
    if (i2c_write(st->hw->addr, st->reg->lp_accel_odr, 1, tmp))
        return -1;
    tmp[0] = BIT_LPA_CYCLE;
    if (i2c_write(st->hw->addr, st->reg->pwr_mgmt_1, 1, tmp))
        return -1;
#endif
    st->chip_cfg.sensors = INV_XYZ_ACCEL;
    st->chip_cfg.clk_src = 0;
    st->chip_cfg.lp_accel_mode = 1;
    MPU_ConfigureFIFO(0);

    return 0;
}

/**
 *  @brief      Enable latched interrupts.
 *  Any MPU register will clear the interrupt.
 *  @param[in]  enable  1 to enable, 0 to disable.
 *  @return     0 if successful.
 */
int MPU_SetIntLatched(uint8_t enable) {
    uint8_t tmp;
    if (st->chip_cfg.latched_int == enable)
        return 0;

    if (enable)
        tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
    else
        tmp = 0;
    if (st->chip_cfg.bypass_mode)
        tmp |= BIT_BYPASS_EN;
    if (st->chip_cfg.active_low_int)
        tmp |= BIT_ACTL;
    MPU_WriteByte(st->reg->int_pin_cfg, tmp);
    st->chip_cfg.latched_int = enable;
    return 0;
}


/**
 *  @brief      Select which sensors are pushed to FIFO.
 *  @e sensors can contain a combination of the following flags:
 *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
 *  \n INV_XYZ_GYRO
 *  \n INV_XYZ_ACCEL
 *  @param[in]  sensors Mask of sensors to push to FIFO.
 *  @return     0 if successful.
 */
int MPU_ConfigureFIFO(uint8_t sensors) {
    uint8_t prev;
    int result = 0;

    /* Compass data isn't going into the FIFO. Stop trying. */
    sensors &= ~INV_XYZ_COMPASS;

    if (st->chip_cfg.dmp_on)
        return 0;
    else {
        if (!(st->chip_cfg.sensors))
            return -1;
        prev = st->chip_cfg.fifo_enable;
        st->chip_cfg.fifo_enable = sensors & st->chip_cfg.sensors;
        if (st->chip_cfg.fifo_enable != sensors)
            /* You're not getting what you asked for. Some sensors are
             * asleep.
             */
            result = -1;
        else
            result = 0;
        if (sensors || st->chip_cfg.lp_accel_mode)
            MPU_SetIntEnable(1);
        else
            MPU_SetIntEnable(0);
        if (sensors) {
            if (MPU_ResetFIFO()) {
                st->chip_cfg.fifo_enable = prev;
                return -1;
            }
        }
    }
    return result;
}

/**
 *  @brief  Reset FIFO read/write pointers.
 *  @return 0 if successful.
 */
int MPU_ResetFIFO(void) {
    uint8_t data;

    if (!(st->chip_cfg.sensors))
        return -1;

    data = 0;
    if (MPU_WriteByteAndCheck(st->reg->int_enable, 0x00)) {
        return -3;
    }
    if (MPU_WriteByteAndCheck(st->reg->fifo_en, 0x00)) {
        return -3;
    }
    if (MPU_WriteByteAndCheck(st->reg->user_ctrl, 0x00)) {
        return -3;
    }

    if (st->chip_cfg.dmp_on) {
        MPU_WriteByte(st->reg->user_ctrl, BIT_FIFO_RST | BIT_DMP_RST);
        Delay_ms(50);
        data = BIT_DMP_EN | BIT_FIFO_EN;
        if (st->chip_cfg.sensors & INV_XYZ_COMPASS)
            data |= BIT_AUX_IF_EN;
        if (MPU_WriteByteAndCheck(st->reg->user_ctrl, data)) {
            return -3;
        }
        if (st->chip_cfg.int_enable)
            data = BIT_DMP_INT_EN;
        else
            data = 0;
        if (MPU_WriteByteAndCheck(st->reg->int_enable, data)) {
            return -3;
        }
        if (MPU_WriteByteAndCheck(st->reg->fifo_en, 0x00)) {
            return -3;
        }
    } else {
        MPU_WriteByte(st->reg->user_ctrl, BIT_FIFO_RST);
        if (st->chip_cfg.bypass_mode || !(st->chip_cfg.sensors & INV_XYZ_COMPASS))
            data = BIT_FIFO_EN;
        else
            data = BIT_FIFO_EN | BIT_AUX_IF_EN;
        if (MPU_WriteByteAndCheck(st->reg->user_ctrl, data)) {
            return -3;
        }
        Delay_ms(50);
        if (st->chip_cfg.int_enable)
            data = BIT_DATA_RDY_EN;
        else
            data = 0;
        if (MPU_WriteByteAndCheck(st->reg->int_enable,data)) {
            return -3;
        }
        if (MPU_WriteByteAndCheck(st->reg->fifo_en, st->chip_cfg.fifo_enable)) {
            return -3;
        }
    }
    return 0;
}

/**
 *  @brief      Enable/disable data ready interrupt.
 *  If the DMP is on, the DMP interrupt is enabled. Otherwise, the data ready
 *  interrupt is used.
 *  @param[in]  enable      1 to enable interrupt.
 *  @return     0 if successful.
 */
int MPU_SetIntEnable(uint8_t enable) {
    uint8_t tmp;

    if (st->chip_cfg.dmp_on) {
        if (enable)
            tmp = BIT_DMP_INT_EN;
        else
            tmp = 0x00;
        if (MPU_WriteByteAndCheck(st->reg->int_enable, tmp)) {
            return -3;
        }
        st->chip_cfg.int_enable = tmp;
    } else {
        if (!st->chip_cfg.sensors)
            return -1;
        if (enable && st->chip_cfg.int_enable)
            return 0;
        if (enable)
            tmp = BIT_DATA_RDY_EN;
        else
            tmp = 0x00;
        if (MPU_WriteByteAndCheck(st->reg->int_enable, tmp)) {
            return -3;
        }
        st->chip_cfg.int_enable = tmp;
    }
    return 0;
}

/**
 *  @brief      Set compass sampling rate.
 *  The compass on the auxiliary I2C bus is read by the MPU hardware at a
 *  maximum of 100Hz. The actual rate can be set to a fraction of the gyro
 *  sampling rate.
 *
 *  \n WARNING: The new rate may be different than what was requested. Call
 *  mpu_get_compass_sample_rate to check the actual setting.
 *  @param[in]  rate    Desired compass sampling rate (Hz).
 *  @return     0 if successful.
 */
int MPU_SetCompassSampleRate(uint8_t rate) {
#ifdef AK89xx_SECONDARY
    uint8_t div;
    if (!rate || rate > st->chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
        return -1;

    div = st->chip_cfg.sample_rate / rate - 1;
    MPU_WriteByte(st->reg->s4_ctrl, div);
    st->chip_cfg.compass_sample_rate = st->chip_cfg.sample_rate / (div + 1);
    return 0;
#else
    return -1;
#endif
}

/**
 *  @brief      Turn specific sensors on/off.
 *  @e sensors can contain a combination of the following flags:
 *  \n INV_X_GYRO, INV_Y_GYRO, INV_Z_GYRO
 *  \n INV_XYZ_GYRO
 *  \n INV_XYZ_ACCEL
 *  \n INV_XYZ_COMPASS
 *  @param[in]  sensors    Mask of sensors to wake.
 *  @return     0 if successful.
 */
int MPU_SetSensors(uint8_t sensors)  {
    uint8_t data;
#ifdef AK89xx_SECONDARY
    uint8_t user_ctrl;
#endif

    if (sensors & INV_XYZ_GYRO)
        data = INV_CLK_PLL;
    else if (sensors)
        data = 0;
    else
        data = BIT_SLEEP;
    if (MPU_WriteByteAndCheck(st->reg->pwr_mgmt_1, data)) {
        return -3;
    }
    
    st->chip_cfg.clk_src = data & ~BIT_SLEEP;

    data = 0;
    if (!(sensors & INV_X_GYRO))
        data |= BIT_STBY_XG;
    if (!(sensors & INV_Y_GYRO))
        data |= BIT_STBY_YG;
    if (!(sensors & INV_Z_GYRO))
        data |= BIT_STBY_ZG;
    if (!(sensors & INV_XYZ_ACCEL))
        data |= BIT_STBY_XYZA;
    if (MPU_WriteByteAndCheck(st->reg->pwr_mgmt_2, data)) {
        return -3;
    }

    if (sensors && (sensors != INV_XYZ_ACCEL))
        /* Latched interrupts only used in LP accel mode. */
        MPU_SetIntLatched(0);

#ifdef AK89xx_SECONDARY
#ifdef AK89xx_BYPASS
    if (sensors & INV_XYZ_COMPASS)
        mpu_set_bypass(1);
    else
        mpu_set_bypass(0);
#else
    user_ctrl = MPU_ReadByte(st->reg->user_ctrl);
    /* Handle AKM power management. */
    if (sensors & INV_XYZ_COMPASS) {
        data = AKM_SINGLE_MEASUREMENT;
        user_ctrl |= BIT_AUX_IF_EN;
    } else {
        data = AKM_POWER_DOWN;
        user_ctrl &= ~BIT_AUX_IF_EN;
    }
    if (st->chip_cfg.dmp_on)
        user_ctrl |= BIT_DMP_EN;
    else
        user_ctrl &= ~BIT_DMP_EN;
    if (MPU_WriteByteAndCheck(st->reg->s1_do, data)) {
        return -3;
    }
    /* Enable/disable I2C master mode. */
    if (MPU_WriteByteAndCheck(st->reg->user_ctrl, user_ctrl)) {
        return -3;
    }
#endif
#endif
    st->chip_cfg.sensors = sensors;
    st->chip_cfg.lp_accel_mode = 0;
    Delay_ms(50);
    return 0;
}

void Mag_WriteByte(uint8_t address, uint8_t data) {
    // Mag I2C address
    MPU_WriteByte(I2C_SLV0_ADDR, WRITE_COMMAND | AK8963_I2C_ADDRESS);
    MPU_WriteByte(I2C_SLV0_REG, address);
    MPU_WriteByte(I2C_SLV0_DO, data);
    // I2C on, 1 byte
    MPU_WriteByte(I2C_SLV0_CTRL, 0x81);
}

uint8_t Mag_ReadByte(uint8_t address) {
    uint8_t tmp;
    // Mag I2C address
    MPU_WriteByte(I2C_SLV0_ADDR, READ_COMMAND | AK8963_I2C_ADDRESS);
    MPU_WriteByte(I2C_SLV0_REG, address);
    // I2C on, 1 byte
    MPU_WriteByte(I2C_SLV0_CTRL, 0x81);
    Delay_ms(1);
    tmp = MPU_ReadByte(EXT_SENS_DATA_00);
    return tmp;
}

void Mag_Read(uint8_t address, uint8_t *data, uint8_t size) {
    // I2C address for reading
    MPU_WriteByte(I2C_SLV0_ADDR, READ_COMMAND | AK8963_I2C_ADDRESS);
    // reading from ASAX register
    MPU_WriteByte(I2C_SLV0_REG, address);
    // Read 3 bytes
    MPU_WriteByte(I2C_SLV0_CTRL, 0x80 | size);
    Delay_ms(1);
    MPU_Read(EXT_SENS_DATA_00, data, 3);
}

/* This initialization is similar to the one in ak8975.c. */
static int setup_compass(void)
{
#ifdef AK89xx_SECONDARY
    uint8_t data[4], akm_addr;

    MPU_SetBypass(1);

    /* Find compass. Possible addresses range from 0x0C to 0x0F. */
    for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
        data[0] = Mag_ReadByte(AKM_REG_WHOAMI);
        if (data[0] == AKM_WHOAMI)
            break;
    }

    if (akm_addr > 0x0F) {
        /* TODO: Handle this case in all compass-related functions. */
        return -1;
    }

    st->chip_cfg.compass_addr = akm_addr;

    Mag_WriteByte(AKM_REG_CNTL, AKM_POWER_DOWN);
    Delay_ms(1);

    data[0] = AKM_FUSE_ROM_ACCESS;
    Mag_WriteByte(AKM_REG_CNTL, AKM_FUSE_ROM_ACCESS);
    Delay_ms(1);

    /* Get sensitivity adjustment data from fuse ROM. */
    Mag_Read(AKM_REG_ASAX, data, 3);
    st->chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
    st->chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
    st->chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;

    data[0] = AKM_POWER_DOWN;
    Mag_WriteByte(AKM_REG_CNTL, AKM_POWER_DOWN);
    Delay_ms(1);

    MPU_SetBypass(0);

    /* Set up master mode, master clock, and ES bit. */
    MPU_WriteByte(st->reg->i2c_mst, 0x40);

    /* Slave 0 reads from AKM data registers. */
    MPU_WriteByte(st->reg->s0_addr, BIT_I2C_READ | st->chip_cfg.compass_addr);

    /* Compass reads start at this register. */
    MPU_WriteByte(st->reg->s0_reg, AKM_REG_ST1);

    /* Enable slave 0, 8-byte reads. */
    MPU_WriteByte(st->reg->s0_ctrl, BIT_SLAVE_EN | 8);

    /* Slave 1 changes AKM measurement mode. */
    MPU_WriteByte(st->reg->s1_addr, st->chip_cfg.compass_addr);

    /* AKM measurement mode register. */
    MPU_WriteByte(st->reg->s1_reg, AKM_REG_CNTL);

    /* Enable slave 1, 1-byte writes. */
    MPU_WriteByte(st->reg->s1_ctrl, BIT_SLAVE_EN | 1);

    /* Set slave 1 data. */
    MPU_WriteByte(st->reg->s1_do, AKM_SINGLE_MEASUREMENT);

    /* Trigger slave 0 and slave 1 actions at each sample. */
    MPU_WriteByte(st->reg->i2c_delay_ctrl, 0x03);

#ifdef MPU9150
    /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
    MPU_WriteByte(st->reg->yg_offs_tc, BIT_I2C_MST_VDDIO);
#endif

    return 0;
#else
    return -16;
#endif
}

/**
 *  @brief      Set device to bypass mode.
 *  @param[in]  bypass_on   1 to enable bypass mode.
 *  @return     0 if successful.
 */
int MPU_SetBypass(uint8_t bypass_on) {
    uint8_t tmp;

    if (st->chip_cfg.bypass_mode == bypass_on)
        return 0;

    if (bypass_on) {
        MPU_WriteByte(st->reg->user_ctrl, tmp);
        tmp &= ~BIT_AUX_IF_EN;
        MPU_WriteByte(st->reg->user_ctrl, tmp);
        Delay_ms(3);
        tmp = BIT_BYPASS_EN;
        if (st->chip_cfg.active_low_int)
            tmp |= BIT_ACTL;
        if (st->chip_cfg.latched_int)
            tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
        MPU_WriteByte(st->reg->int_pin_cfg, tmp);
    } else {
        /* Enable I2C master mode if compass is being used. */
        MPU_WriteByte(st->reg->user_ctrl, tmp);
 
        if (st->chip_cfg.sensors & INV_XYZ_COMPASS)
            tmp |= BIT_AUX_IF_EN;
        else
            tmp &= ~BIT_AUX_IF_EN;
        MPU_WriteByte(st->reg->user_ctrl, tmp);
        Delay_ms(3);
        if (st->chip_cfg.active_low_int)
            tmp = BIT_ACTL;
        else
            tmp = 0;
        if (st->chip_cfg.latched_int)
            tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
        MPU_WriteByte(st->reg->int_pin_cfg, tmp);
    }
    st->chip_cfg.bypass_mode = bypass_on;
    return 0;
}


//uint8_t imu_test = 0;
//void MPU_Init() {
//    // WHO_AM_I, reset value = 0x71
//    imu_test = MPU_ReadByte(WHO_AM_I);
//    
//    // PLL as clock source
//    MPU_WriteByte(PWR_MGMT_1, 0x01);
//    imu_test = MPU_ReadByte(PWR_MGMT_1);

//    // 1000 Hz sample rate, 41 Hz gyro bandwidth
//    MPU_WriteByte(CONFIG, 0x03);
//    imu_test = MPU_ReadByte(CONFIG);   
//    
//    // divisor = 5, sample rate -> 200 Hz
//    MPU_WriteByte(SMPLRT_DIV, 0x04);
//    imu_test = MPU_ReadByte(SMPLRT_DIV);
//    
//    // gyro sensitivity - 250 dps
//    MPU_WriteByte(GYRO_CONFIG, 0x00);
//    imu_test = MPU_ReadByte(GYRO_CONFIG);
//    
//    // accel sensitivity - +-16g
//    MPU_WriteByte(ACCEL_CONFIG, 0x18);
//    imu_test = MPU_ReadByte(ACCEL_CONFIG);
//    
//    // 41 Hz accel bandwidth, 1000 Hz sample rate
//    MPU_WriteByte(ACCEL_CONFIG2, 0x03);
//    imu_test = MPU_ReadByte(ACCEL_CONFIG2);
//   
//    // Interrupt implemented by constant level, not pulses
//    MPU_WriteByte(INT_PIN_CFG, 0x30);
//    imu_test = MPU_ReadByte(INT_PIN_CFG);
//    
//    // Raw data ready interrupt enable
//    MPU_WriteByte(INT_ENABLE, 0x01);
//    imu_test = MPU_ReadByte(INT_ENABLE);
//    
//    // enable FIFO
////    MPU_WriteByte(USER_CTRL, 0x40);
////    imu_test = MPU_ReadByte(USER_CTRL);
////    
////    // accel, gyro, temp data to fifo
////    MPU_WriteByte(FIFO_EN, 0xf8);
////    imu_test = MPU_ReadByte(FIFO_EN);
//    
//    // enable DMP and FIFO
////    MPU_WriteByte(USER_CTRL, 0xc0);
////    imu_test = MPU_ReadByte(USER_CTRL);
////    
////    // no sensors data to FIFO
////    MPU_WriteByte(FIFO_EN, 0x00);
////    imu_test = MPU_ReadByte(FIFO_EN);
////    
////    // DMP interrupt enable
////    MPU_WriteByte(INT_ENABLE, 0x20);
////    imu_test = MPU_ReadByte(INT_ENABLE);
//}

void MPU_EXTI_Init() {
    GPIOA->OSPEEDR |= 3 << IMU_INT*2;
    
    SYSCFG->EXTICR[0] |= SYSCFG_EXTICR1_EXTI1_PA;
    
    EXTI->RTSR  |= EXTI_RTSR_TR1;       // rising
    EXTI->IMR   |= EXTI_IMR_MR1;        // non-masking
    NVIC_SetPriority(EXTI1_IRQn, 0x02);
    NVIC_EnableIRQ(EXTI1_IRQn);
}

void EXTI1_IRQHandler() {
    uint16_t fifo_count = 0;
    uint8_t tmp[2];
    if (EXTI->PR & EXTI_PR_PR1) {
        EXTI->PR = EXTI_PR_PR1;
        
        MPU_Read(FIFO_COUNTH, tmp, 2);
        fifo_count = (tmp[0] << 8) | tmp[1];
        if (fifo_count) {
            MPU_DMA_Run(MPU_DMA_tx, MPU_DMA_rx, MPU_READ_DATA_SIZE);
        }
    }
}



void swap(float *a, float *b) {
    float tmp = *a;
    *a = *b;
    *b = tmp;
}

void DMA1_Stream3_IRQHandler() {
    uint8_t i = 0;
    int16_t tmp = 0;
    if (DMA1->LISR & DMA_LISR_TCIF3) {
        DMA1->LIFCR = DMA_LIFCR_CTCIF3 | DMA_LIFCR_CHTIF3;
        DMA1_Stream3->CR &= ~DMA_SxCR_EN;
        MPU_NSS_High();
        
        for (i = 0; i < 3; i++) {
            tmp = (MPU_DMA_rx[2*i+1] << 8) | MPU_DMA_rx[2*i+2];
            accel[i] = tmp / ACCEL_SENSITIVITY;
        }
        
//        tmp = (MPU_DMA_rx[7] << 8) | MPU_DMA_rx[8];
//        temp = tmp / TEMP_SENSITIBITY + TEMP_OFFSET;
        
        for (i = 0; i < 3; i++) {
            tmp = (MPU_DMA_rx[2*i+7] << 8) | MPU_DMA_rx[2*i+8];
            angleRate[i] = -tmp / GYRO_SENSITIVITY; // for QUEST algorithm
        }
        
//        for (i = 0; i < 3; i++) {
//            tmp = MPU_DMA_rx[2*i+15] | (MPU_DMA_rx[2*i+16] << 8);
//            magField[i] = tmp * MAG_SENSITIVITY * mag_sens_adj[i];
//        }
//        magField[2] = -magField[2];
//        swap(&magField[0], &magField[1]);  
        
//        if (meas1) {
//            meas1 = 0;
//            memcpy(w1, accel, VECT_SIZE*sizeof(float));
//            memcpy(w2, magField, VECT_SIZE*sizeof(float));
//            
//            Vect_Norm(w1);
//            Vect_Norm(w2);
//        } else {
//            process = 1;
//            memcpy(v1, accel, VECT_SIZE*sizeof(float));
//            memcpy(v2, magField, VECT_SIZE*sizeof(float));
//            
//            Vect_Norm(v1);
//            Vect_Norm(v2);
//        }
    }
}

void Mag_Init() {
    uint8_t tmp[3], i = 0;
    
    // Enable I2C master
    MPU_WriteByte(USER_CTRL, 0x20);
    
    Mag_WriteByte(AK8963_CNTL, 0x00); // Power down magnetometer  
    Delay_ms(10);   
    Mag_WriteByte(AK8963_CNTL, 0x0f); // Enter Fuse ROM access mode
    Delay_ms(10);
    
    // I2C address for reading
    MPU_WriteByte(I2C_SLV0_ADDR, READ_COMMAND | AK8963_I2C_ADDRESS);
    // reading from ASAX register
    MPU_WriteByte(I2C_SLV0_REG, AK8963_ASAX);
    // Read 3 bytes
    MPU_WriteByte(I2C_SLV0_CTRL, 0x83);
    Delay_ms(10);
    MPU_Read(EXT_SENS_DATA_00, tmp, 3);
    
    for (i = 0; i < 3; i++) {
        mag_sens_adj[i] = (tmp[i] - 128)*0.5 / 128.0f + 1.0f;
    }
    
    Mag_WriteByte(AK8963_CNTL, 0x00); // Power down magnetometer  
    Delay_ms(10);
    

    Mag_WriteByte(AK8963_CNTL, 0x16); // Continuous measurement mode 2 (100 Hz), 16 bit output
    Delay_ms(10);
    
    // Data ready interrupt waits for external sensor data
    MPU_WriteByte(I2C_MST_CTRL, 0x40);
    // I2C address for reading
    MPU_WriteByte(I2C_SLV0_ADDR, READ_COMMAND | AK8963_I2C_ADDRESS);
    // reading from HXL register
    MPU_WriteByte(I2C_SLV0_REG, AK8963_HXL);
    // Read 7 bytes
    MPU_WriteByte(I2C_SLV0_CTRL, 0x87);
}



uint8_t dmp_memory[DMP_CODE_SIZE] = {
    /* bank # 0 */
    0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
    0x00, 0x65, 0x00, 0x54, 0xff, 0xef, 0x00, 0x00, 0xfa, 0x80, 0x00, 0x0b, 0x12, 0x82, 0x00, 0x01,
    0x03, 0x0c, 0x30, 0xc3, 0x0e, 0x8c, 0x8c, 0xe9, 0x14, 0xd5, 0x40, 0x02, 0x13, 0x71, 0x0f, 0x8e,
    0x38, 0x83, 0xf8, 0x83, 0x30, 0x00, 0xf8, 0x83, 0x25, 0x8e, 0xf8, 0x83, 0x30, 0x00, 0xf8, 0x83,
    0xff, 0xff, 0xff, 0xff, 0x0f, 0xfe, 0xa9, 0xd6, 0x24, 0x00, 0x04, 0x00, 0x1a, 0x82, 0x79, 0xa1,
    0x00, 0x00, 0x00, 0x3c, 0xff, 0xff, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x38, 0x83, 0x6f, 0xa2,
    0x00, 0x3e, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xca, 0xe3, 0x09, 0x3e, 0x80, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
    0x00, 0x0c, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x6e, 0x00, 0x00, 0x06, 0x92, 0x0a, 0x16, 0xc0, 0xdf,
    0xff, 0xff, 0x02, 0x56, 0xfd, 0x8c, 0xd3, 0x77, 0xff, 0xe1, 0xc4, 0x96, 0xe0, 0xc5, 0xbe, 0xaa,
    0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0b, 0x2b, 0x00, 0x00, 0x16, 0x57, 0x00, 0x00, 0x03, 0x59,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1d, 0xfa, 0x00, 0x02, 0x6c, 0x1d, 0x00, 0x00, 0x00, 0x00,
    0x3f, 0xff, 0xdf, 0xeb, 0x00, 0x3e, 0xb3, 0xb6, 0x00, 0x0d, 0x22, 0x78, 0x00, 0x00, 0x2f, 0x3c,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x19, 0x42, 0xb5, 0x00, 0x00, 0x39, 0xa2, 0x00, 0x00, 0xb3, 0x65,
    0xd9, 0x0e, 0x9f, 0xc9, 0x1d, 0xcf, 0x4c, 0x34, 0x30, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x3b, 0xb6, 0x7a, 0xe8, 0x00, 0x64, 0x00, 0x00, 0x00, 0xc8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    /* bank # 1 */
    0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0xfa, 0x92, 0x10, 0x00, 0x22, 0x5e, 0x00, 0x0d, 0x22, 0x9f,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0xff, 0x46, 0x00, 0x00, 0x63, 0xd4, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x04, 0xd6, 0x00, 0x00, 0x04, 0xcc, 0x00, 0x00, 0x04, 0xcc, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x72, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x06, 0x00, 0x02, 0x00, 0x05, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0x64, 0x00, 0x20, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x03, 0x00,
    0x00, 0x00, 0x00, 0x32, 0xf8, 0x98, 0x00, 0x00, 0xff, 0x65, 0x00, 0x00, 0x83, 0x0f, 0x00, 0x00,
    0xff, 0x9b, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0xb2, 0x6a, 0x00, 0x02, 0x00, 0x00,
    0x00, 0x01, 0xfb, 0x83, 0x00, 0x68, 0x00, 0x00, 0x00, 0xd9, 0xfc, 0x00, 0x7c, 0xf1, 0xff, 0x83,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x64, 0x03, 0xe8, 0x00, 0x64, 0x00, 0x28,
    0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0x16, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
    0x00, 0x00, 0x10, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x00, 0x01, 0xf4, 0x00, 0x00, 0x10, 0x00,
    /* bank # 2 */
    0x00, 0x28, 0x00, 0x00, 0xff, 0xff, 0x45, 0x81, 0xff, 0xff, 0xfa, 0x72, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0x00, 0x05, 0x00, 0x05, 0xba, 0xc6, 0x00, 0x47, 0x78, 0xa2,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
    0x00, 0x00, 0x25, 0x4d, 0x00, 0x2f, 0x70, 0x6d, 0x00, 0x00, 0x05, 0xae, 0x00, 0x0c, 0x02, 0xd0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x64, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x1b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x0e,
    0x00, 0x00, 0x0a, 0xc7, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0xff, 0xff, 0xff, 0x9c,
    0x00, 0x00, 0x0b, 0x2b, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x64,
    0xff, 0xe5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    /* bank # 3 */
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x24, 0x26, 0xd3,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x10, 0x00, 0x96, 0x00, 0x3c,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0c, 0x0a, 0x4e, 0x68, 0xcd, 0xcf, 0x77, 0x09, 0x50, 0x16, 0x67, 0x59, 0xc6, 0x19, 0xce, 0x82,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x17, 0xd7, 0x84, 0x00, 0x03, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x93, 0x8f, 0x9d, 0x1e, 0x1b, 0x1c, 0x19,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x18, 0x85, 0x00, 0x00, 0x40, 0x00,
    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x67, 0x7d, 0xdf, 0x7e, 0x72, 0x90, 0x2e, 0x55, 0x4c, 0xf6, 0xe6, 0x88,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    /* bank # 4 */
    0xd8, 0xdc, 0xb4, 0xb8, 0xb0, 0xd8, 0xb9, 0xab, 0xf3, 0xf8, 0xfa, 0xb3, 0xb7, 0xbb, 0x8e, 0x9e,
    0xae, 0xf1, 0x32, 0xf5, 0x1b, 0xf1, 0xb4, 0xb8, 0xb0, 0x80, 0x97, 0xf1, 0xa9, 0xdf, 0xdf, 0xdf,
    0xaa, 0xdf, 0xdf, 0xdf, 0xf2, 0xaa, 0xc5, 0xcd, 0xc7, 0xa9, 0x0c, 0xc9, 0x2c, 0x97, 0xf1, 0xa9,
    0x89, 0x26, 0x46, 0x66, 0xb2, 0x89, 0x99, 0xa9, 0x2d, 0x55, 0x7d, 0xb0, 0xb0, 0x8a, 0xa8, 0x96,
    0x36, 0x56, 0x76, 0xf1, 0xba, 0xa3, 0xb4, 0xb2, 0x80, 0xc0, 0xb8, 0xa8, 0x97, 0x11, 0xb2, 0x83,
    0x98, 0xba, 0xa3, 0xf0, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xb2, 0xb9, 0xb4, 0x98, 0x83, 0xf1,
    0xa3, 0x29, 0x55, 0x7d, 0xba, 0xb5, 0xb1, 0xa3, 0x83, 0x93, 0xf0, 0x00, 0x28, 0x50, 0xf5, 0xb2,
    0xb6, 0xaa, 0x83, 0x93, 0x28, 0x54, 0x7c, 0xf1, 0xb9, 0xa3, 0x82, 0x93, 0x61, 0xba, 0xa2, 0xda,
    0xde, 0xdf, 0xdb, 0x81, 0x9a, 0xb9, 0xae, 0xf5, 0x60, 0x68, 0x70, 0xf1, 0xda, 0xba, 0xa2, 0xdf,
    0xd9, 0xba, 0xa2, 0xfa, 0xb9, 0xa3, 0x82, 0x92, 0xdb, 0x31, 0xba, 0xa2, 0xd9, 0xba, 0xa2, 0xf8,
    0xdf, 0x85, 0xa4, 0xd0, 0xc1, 0xbb, 0xad, 0x83, 0xc2, 0xc5, 0xc7, 0xb8, 0xa2, 0xdf, 0xdf, 0xdf,
    0xba, 0xa0, 0xdf, 0xdf, 0xdf, 0xd8, 0xd8, 0xf1, 0xb8, 0xaa, 0xb3, 0x8d, 0xb4, 0x98, 0x0d, 0x35,
    0x5d, 0xb2, 0xb6, 0xba, 0xaf, 0x8c, 0x96, 0x19, 0x8f, 0x9f, 0xa7, 0x0e, 0x16, 0x1e, 0xb4, 0x9a,
    0xb8, 0xaa, 0x87, 0x2c, 0x54, 0x7c, 0xba, 0xa4, 0xb0, 0x8a, 0xb6, 0x91, 0x32, 0x56, 0x76, 0xb2,
    0x84, 0x94, 0xa4, 0xc8, 0x08, 0xcd, 0xd8, 0xb8, 0xb4, 0xb0, 0xf1, 0x99, 0x82, 0xa8, 0x2d, 0x55,
    0x7d, 0x98, 0xa8, 0x0e, 0x16, 0x1e, 0xa2, 0x2c, 0x54, 0x7c, 0x92, 0xa4, 0xf0, 0x2c, 0x50, 0x78,
    /* bank # 5 */
    0xf1, 0x84, 0xa8, 0x98, 0xc4, 0xcd, 0xfc, 0xd8, 0x0d, 0xdb, 0xa8, 0xfc, 0x2d, 0xf3, 0xd9, 0xba,
    0xa6, 0xf8, 0xda, 0xba, 0xa6, 0xde, 0xd8, 0xba, 0xb2, 0xb6, 0x86, 0x96, 0xa6, 0xd0, 0xf3, 0xc8,
    0x41, 0xda, 0xa6, 0xc8, 0xf8, 0xd8, 0xb0, 0xb4, 0xb8, 0x82, 0xa8, 0x92, 0xf5, 0x2c, 0x54, 0x88,
    0x98, 0xf1, 0x35, 0xd9, 0xf4, 0x18, 0xd8, 0xf1, 0xa2, 0xd0, 0xf8, 0xf9, 0xa8, 0x84, 0xd9, 0xc7,
    0xdf, 0xf8, 0xf8, 0x83, 0xc5, 0xda, 0xdf, 0x69, 0xdf, 0x83, 0xc1, 0xd8, 0xf4, 0x01, 0x14, 0xf1,
    0xa8, 0x82, 0x4e, 0xa8, 0x84, 0xf3, 0x11, 0xd1, 0x82, 0xf5, 0xd9, 0x92, 0x28, 0x97, 0x88, 0xf1,
    0x09, 0xf4, 0x1c, 0x1c, 0xd8, 0x84, 0xa8, 0xf3, 0xc0, 0xf9, 0xd1, 0xd9, 0x97, 0x82, 0xf1, 0x29,
    0xf4, 0x0d, 0xd8, 0xf3, 0xf9, 0xf9, 0xd1, 0xd9, 0x82, 0xf4, 0xc2, 0x03, 0xd8, 0xde, 0xdf, 0x1a,
    0xd8, 0xf1, 0xa2, 0xfa, 0xf9, 0xa8, 0x84, 0x98, 0xd9, 0xc7, 0xdf, 0xf8, 0xf8, 0xf8, 0x83, 0xc7,
    0xda, 0xdf, 0x69, 0xdf, 0xf8, 0x83, 0xc3, 0xd8, 0xf4, 0x01, 0x14, 0xf1, 0x98, 0xa8, 0x82, 0x2e,
    0xa8, 0x84, 0xf3, 0x11, 0xd1, 0x82, 0xf5, 0xd9, 0x92, 0x50, 0x97, 0x88, 0xf1, 0x09, 0xf4, 0x1c,
    0xd8, 0x84, 0xa8, 0xf3, 0xc0, 0xf8, 0xf9, 0xd1, 0xd9, 0x97, 0x82, 0xf1, 0x49, 0xf4, 0x0d, 0xd8,
    0xf3, 0xf9, 0xf9, 0xd1, 0xd9, 0x82, 0xf4, 0xc4, 0x03, 0xd8, 0xde, 0xdf, 0xd8, 0xf1, 0xad, 0x88,
    0x98, 0xcc, 0xa8, 0x09, 0xf9, 0xd9, 0x82, 0x92, 0xa8, 0xf5, 0x7c, 0xf1, 0x88, 0x3a, 0xcf, 0x94,
    0x4a, 0x6e, 0x98, 0xdb, 0x69, 0x31, 0xda, 0xad, 0xf2, 0xde, 0xf9, 0xd8, 0x87, 0x95, 0xa8, 0xf2,
    0x21, 0xd1, 0xda, 0xa5, 0xf9, 0xf4, 0x17, 0xd9, 0xf1, 0xae, 0x8e, 0xd0, 0xc0, 0xc3, 0xae, 0x82,
    /* bank # 6 */
    0xc6, 0x84, 0xc3, 0xa8, 0x85, 0x95, 0xc8, 0xa5, 0x88, 0xf2, 0xc0, 0xf1, 0xf4, 0x01, 0x0e, 0xf1,
    0x8e, 0x9e, 0xa8, 0xc6, 0x3e, 0x56, 0xf5, 0x54, 0xf1, 0x88, 0x72, 0xf4, 0x01, 0x15, 0xf1, 0x98,
    0x45, 0x85, 0x6e, 0xf5, 0x8e, 0x9e, 0x04, 0x88, 0xf1, 0x42, 0x98, 0x5a, 0x8e, 0x9e, 0x06, 0x88,
    0x69, 0xf4, 0x01, 0x1c, 0xf1, 0x98, 0x1e, 0x11, 0x08, 0xd0, 0xf5, 0x04, 0xf1, 0x1e, 0x97, 0x02,
    0x02, 0x98, 0x36, 0x25, 0xdb, 0xf9, 0xd9, 0x85, 0xa5, 0xf3, 0xc1, 0xda, 0x85, 0xa5, 0xf3, 0xdf,
    0xd8, 0x85, 0x95, 0xa8, 0xf3, 0x09, 0xda, 0xa5, 0xfa, 0xd8, 0x82, 0x92, 0xa8, 0xf5, 0x78, 0xf1,
    0x88, 0x1a, 0x84, 0x9f, 0x26, 0x88, 0x98, 0x21, 0xda, 0xf4, 0x1d, 0xf3, 0xd8, 0x87, 0x9f, 0x39,
    0xd1, 0xaf, 0xd9, 0xdf, 0xdf, 0xfb, 0xf9, 0xf4, 0x0c, 0xf3, 0xd8, 0xfa, 0xd0, 0xf8, 0xda, 0xf9,
    0xf9, 0xd0, 0xdf, 0xd9, 0xf9, 0xd8, 0xf4, 0x0b, 0xd8, 0xf3, 0x87, 0x9f, 0x39, 0xd1, 0xaf, 0xd9,
    0xdf, 0xdf, 0xf4, 0x1d, 0xf3, 0xd8, 0xfa, 0xfc, 0xa8, 0x69, 0xf9, 0xf9, 0xaf, 0xd0, 0xda, 0xde,
    0xfa, 0xd9, 0xf8, 0x8f, 0x9f, 0xa8, 0xf1, 0xcc, 0xf3, 0x98, 0xdb, 0x45, 0xd9, 0xaf, 0xdf, 0xd0,
    0xf8, 0xd8, 0xf1, 0x8f, 0x9f, 0xa8, 0xca, 0xf3, 0x88, 0x09, 0xda, 0xaf, 0x8f, 0xcb, 0xf8, 0xd8,
    0xf2, 0xad, 0x97, 0x8d, 0x0c, 0xd9, 0xa5, 0xdf, 0xf9, 0xba, 0xa6, 0xf3, 0xfa, 0xf4, 0x12, 0xf2,
    0xd8, 0x95, 0x0d, 0xd1, 0xd9, 0xba, 0xa6, 0xf3, 0xfa, 0xda, 0xa5, 0xf2, 0xc1, 0xba, 0xa6, 0xf3,
    0xdf, 0xd8, 0xf1, 0xba, 0xb2, 0xb6, 0x86, 0x96, 0xa6, 0xd0, 0xca, 0xf3, 0x49, 0xda, 0xa6, 0xcb,
    0xf8, 0xd8, 0xb0, 0xb4, 0xb8, 0xd8, 0xad, 0x84, 0xf2, 0xc0, 0xdf, 0xf1, 0x8f, 0xcb, 0xc3, 0xa8,
    /* bank # 7 */
    0xb2, 0xb6, 0x86, 0x96, 0xc8, 0xc1, 0xcb, 0xc3, 0xf3, 0xb0, 0xb4, 0x88, 0x98, 0xa8, 0x21, 0xdb,
    0x71, 0x8d, 0x9d, 0x71, 0x85, 0x95, 0x21, 0xd9, 0xad, 0xf2, 0xfa, 0xd8, 0x85, 0x97, 0xa8, 0x28,
    0xd9, 0xf4, 0x08, 0xd8, 0xf2, 0x8d, 0x29, 0xda, 0xf4, 0x05, 0xd9, 0xf2, 0x85, 0xa4, 0xc2, 0xf2,
    0xd8, 0xa8, 0x8d, 0x94, 0x01, 0xd1, 0xd9, 0xf4, 0x11, 0xf2, 0xd8, 0x87, 0x21, 0xd8, 0xf4, 0x0a,
    0xd8, 0xf2, 0x84, 0x98, 0xa8, 0xc8, 0x01, 0xd1, 0xd9, 0xf4, 0x11, 0xd8, 0xf3, 0xa4, 0xc8, 0xbb,
    0xaf, 0xd0, 0xf2, 0xde, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xd8, 0xf1, 0xb8, 0xf6,
    0xb5, 0xb9, 0xb0, 0x8a, 0x95, 0xa3, 0xde, 0x3c, 0xa3, 0xd9, 0xf8, 0xd8, 0x5c, 0xa3, 0xd9, 0xf8,
    0xd8, 0x7c, 0xa3, 0xd9, 0xf8, 0xd8, 0xf8, 0xf9, 0xd1, 0xa5, 0xd9, 0xdf, 0xda, 0xfa, 0xd8, 0xb1,
    0x85, 0x30, 0xf7, 0xd9, 0xde, 0xd8, 0xf8, 0x30, 0xad, 0xda, 0xde, 0xd8, 0xf2, 0xb4, 0x8c, 0x99,
    0xa3, 0x2d, 0x55, 0x7d, 0xa0, 0x83, 0xdf, 0xdf, 0xdf, 0xb5, 0x91, 0xa0, 0xf6, 0x29, 0xd9, 0xfb,
    0xd8, 0xa0, 0xfc, 0x29, 0xd9, 0xfa, 0xd8, 0xa0, 0xd0, 0x51, 0xd9, 0xf8, 0xd8, 0xfc, 0x51, 0xd9,
    0xf9, 0xd8, 0x79, 0xd9, 0xfb, 0xd8, 0xa0, 0xd0, 0xfc, 0x79, 0xd9, 0xfa, 0xd8, 0xa1, 0xf9, 0xf9,
    0xf9, 0xf9, 0xf9, 0xa0, 0xda, 0xdf, 0xdf, 0xdf, 0xd8, 0xa1, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xac,
    0xde, 0xf8, 0xad, 0xde, 0x83, 0x93, 0xac, 0x2c, 0x54, 0x7c, 0xf1, 0xa8, 0xdf, 0xdf, 0xdf, 0xf6,
    0x9d, 0x2c, 0xda, 0xa0, 0xdf, 0xd9, 0xfa, 0xdb, 0x2d, 0xf8, 0xd8, 0xa8, 0x50, 0xda, 0xa0, 0xd0,
    0xde, 0xd9, 0xd0, 0xf8, 0xf8, 0xf8, 0xdb, 0x55, 0xf8, 0xd8, 0xa8, 0x78, 0xda, 0xa0, 0xd0, 0xdf,
    /* bank # 8 */
    0xd9, 0xd0, 0xfa, 0xf8, 0xf8, 0xf8, 0xf8, 0xdb, 0x7d, 0xf8, 0xd8, 0x9c, 0xa8, 0x8c, 0xf5, 0x30,
    0xdb, 0x38, 0xd9, 0xd0, 0xde, 0xdf, 0xa0, 0xd0, 0xde, 0xdf, 0xd8, 0xa8, 0x48, 0xdb, 0x58, 0xd9,
    0xdf, 0xd0, 0xde, 0xa0, 0xdf, 0xd0, 0xde, 0xd8, 0xa8, 0x68, 0xdb, 0x70, 0xd9, 0xdf, 0xdf, 0xa0,
    0xdf, 0xdf, 0xd8, 0xf1, 0xa8, 0x88, 0x90, 0x2c, 0x54, 0x7c, 0x98, 0xa8, 0xd0, 0x5c, 0x38, 0xd1,
    0xda, 0xf2, 0xae, 0x8c, 0xdf, 0xf9, 0xd8, 0xb0, 0x87, 0xa8, 0xc1, 0xc1, 0xb1, 0x88, 0xa8, 0xc6,
    0xf9, 0xf9, 0xda, 0x36, 0xd8, 0xa8, 0xf9, 0xda, 0x36, 0xd8, 0xa8, 0xf9, 0xda, 0x36, 0xd8, 0xa8,
    0xf9, 0xda, 0x36, 0xd8, 0xa8, 0xf9, 0xda, 0x36, 0xd8, 0xf7, 0x8d, 0x9d, 0xad, 0xf8, 0x18, 0xda,
    0xf2, 0xae, 0xdf, 0xd8, 0xf7, 0xad, 0xfa, 0x30, 0xd9, 0xa4, 0xde, 0xf9, 0xd8, 0xf2, 0xae, 0xde,
    0xfa, 0xf9, 0x83, 0xa7, 0xd9, 0xc3, 0xc5, 0xc7, 0xf1, 0x88, 0x9b, 0xa7, 0x7a, 0xad, 0xf7, 0xde,
    0xdf, 0xa4, 0xf8, 0x84, 0x94, 0x08, 0xa7, 0x97, 0xf3, 0x00, 0xae, 0xf2, 0x98, 0x19, 0xa4, 0x88,
    0xc6, 0xa3, 0x94, 0x88, 0xf6, 0x32, 0xdf, 0xf2, 0x83, 0x93, 0xdb, 0x09, 0xd9, 0xf2, 0xaa, 0xdf,
    0xd8, 0xd8, 0xae, 0xf8, 0xf9, 0xd1, 0xda, 0xf3, 0xa4, 0xde, 0xa7, 0xf1, 0x88, 0x9b, 0x7a, 0xd8,
    0xf3, 0x84, 0x94, 0xae, 0x19, 0xf9, 0xda, 0xaa, 0xf1, 0xdf, 0xd8, 0xa8, 0x81, 0xc0, 0xc3, 0xc5,
    0xc7, 0xa3, 0x92, 0x83, 0xf6, 0x28, 0xad, 0xde, 0xd9, 0xf8, 0xd8, 0xa3, 0x50, 0xad, 0xd9, 0xf8,
    0xd8, 0xa3, 0x78, 0xad, 0xd9, 0xf8, 0xd8, 0xf8, 0xf9, 0xd1, 0xa1, 0xda, 0xde, 0xc3, 0xc5, 0xc7,
    0xd8, 0xa1, 0x81, 0x94, 0xf8, 0x18, 0xf2, 0xb0, 0x89, 0xac, 0xc3, 0xc5, 0xc7, 0xf1, 0xd8, 0xb8,
    /* bank # 9 */
    0xb4, 0xb0, 0x97, 0x86, 0xa8, 0x31, 0x9b, 0x06, 0x99, 0x07, 0xab, 0x97, 0x28, 0x88, 0x9b, 0xf0,
    0x0c, 0x20, 0x14, 0x40, 0xb0, 0xb4, 0xb8, 0xf0, 0xa8, 0x8a, 0x9a, 0x28, 0x50, 0x78, 0xb7, 0x9b,
    0xa8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31, 0xf1, 0xbb, 0xab,
    0x88, 0x00, 0x2c, 0x54, 0x7c, 0xf0, 0xb3, 0x8b, 0xb8, 0xa8, 0x04, 0x28, 0x50, 0x78, 0xf1, 0xb0,
    0x88, 0xb4, 0x97, 0x26, 0xa8, 0x59, 0x98, 0xbb, 0xab, 0xb3, 0x8b, 0x02, 0x26, 0x46, 0x66, 0xb0,
    0xb8, 0xf0, 0x8a, 0x9c, 0xa8, 0x29, 0x51, 0x79, 0x8b, 0x29, 0x51, 0x79, 0x8a, 0x24, 0x70, 0x59,
    0x8b, 0x20, 0x58, 0x71, 0x8a, 0x44, 0x69, 0x38, 0x8b, 0x39, 0x40, 0x68, 0x8a, 0x64, 0x48, 0x31,
    0x8b, 0x30, 0x49, 0x60, 0x88, 0xf1, 0xac, 0x00, 0x2c, 0x54, 0x7c, 0xf0, 0x8c, 0xa8, 0x04, 0x28,
    0x50, 0x78, 0xf1, 0x88, 0x97, 0x26, 0xa8, 0x59, 0x98, 0xac, 0x8c, 0x02, 0x26, 0x46, 0x66, 0xf0,
    0x89, 0x9c, 0xa8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31, 0xa9,
    0x88, 0x09, 0x20, 0x59, 0x70, 0xab, 0x11, 0x38, 0x40, 0x69, 0xa8, 0x19, 0x31, 0x48, 0x60, 0x8c,
    0xa8, 0x3c, 0x41, 0x5c, 0x20, 0x7c, 0x00, 0xf1, 0x87, 0x98, 0x19, 0x86, 0xa8, 0x6e, 0x76, 0x7e,
    0xa9, 0x99, 0x88, 0x2d, 0x55, 0x7d, 0xd8, 0xb1, 0xb5, 0xb9, 0xa3, 0xdf, 0xdf, 0xdf, 0xae, 0xd0,
    0xdf, 0xaa, 0xd0, 0xde, 0xf2, 0xab, 0xf8, 0xf9, 0xd9, 0xb0, 0x87, 0xc4, 0xaa, 0xf1, 0xdf, 0xdf,
    0xbb, 0xaf, 0xdf, 0xdf, 0xb9, 0xd8, 0xb1, 0xf1, 0xa3, 0x97, 0x8e, 0x60, 0xdf, 0xb0, 0x84, 0xf2,
    0xc8, 0xf8, 0xf9, 0xd9, 0xde, 0xd8, 0x93, 0x85, 0xf1, 0x4a, 0xb1, 0x83, 0xa3, 0x08, 0xb5, 0x83,
    /* bank # 10 */
    0x9a, 0x08, 0x10, 0xb7, 0x9f, 0x10, 0xd8, 0xf1, 0xb0, 0xba, 0xae, 0xb0, 0x8a, 0xc2, 0xb2, 0xb6,
    0x8e, 0x9e, 0xf1, 0xfb, 0xd9, 0xf4, 0x1d, 0xd8, 0xf9, 0xd9, 0x0c, 0xf1, 0xd8, 0xf8, 0xf8, 0xad,
    0x61, 0xd9, 0xae, 0xfb, 0xd8, 0xf4, 0x0c, 0xf1, 0xd8, 0xf8, 0xf8, 0xad, 0x19, 0xd9, 0xae, 0xfb,
    0xdf, 0xd8, 0xf4, 0x16, 0xf1, 0xd8, 0xf8, 0xad, 0x8d, 0x61, 0xd9, 0xf4, 0xf4, 0xac, 0xf5, 0x9c,
    0x9c, 0x8d, 0xdf, 0x2b, 0xba, 0xb6, 0xae, 0xfa, 0xf8, 0xf4, 0x0b, 0xd8, 0xf1, 0xae, 0xd0, 0xf8,
    0xad, 0x51, 0xda, 0xae, 0xfa, 0xf8, 0xf1, 0xd8, 0xb9, 0xb1, 0xb6, 0xa3, 0x83, 0x9c, 0x08, 0xb9,
    0xb1, 0x83, 0x9a, 0xb5, 0xaa, 0xc0, 0xfd, 0x30, 0x83, 0xb7, 0x9f, 0x10, 0xb5, 0x8b, 0x93, 0xf2,
    0x02, 0x02, 0xd1, 0xab, 0xda, 0xde, 0xd8, 0xf1, 0xb0, 0x80, 0xba, 0xab, 0xc0, 0xc3, 0xb2, 0x84,
    0xc1, 0xc3, 0xd8, 0xb1, 0xb9, 0xf3, 0x8b, 0xa3, 0x91, 0xb6, 0x09, 0xb4, 0xd9, 0xab, 0xde, 0xb0,
    0x87, 0x9c, 0xb9, 0xa3, 0xdd, 0xf1, 0xb3, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0xb0, 0x87, 0xa3, 0xa3,
    0xa3, 0xa3, 0xb2, 0x8b, 0xb6, 0x9b, 0xf2, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
    0xa3, 0xf1, 0xb0, 0x87, 0xb5, 0x9a, 0xa3, 0xf3, 0x9b, 0xa3, 0xa3, 0xdc, 0xba, 0xac, 0xdf, 0xb9,
    0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
    0xd8, 0xd8, 0xd8, 0xbb, 0xb3, 0xb7, 0xf1, 0xaa, 0xf9, 0xda, 0xff, 0xd9, 0x80, 0x9a, 0xaa, 0x28,
    0xb4, 0x80, 0x98, 0xa7, 0x20, 0xb7, 0x97, 0x87, 0xa8, 0x66, 0x88, 0xf0, 0x79, 0x51, 0xf1, 0x90,
    0x2c, 0x87, 0x0c, 0xa7, 0x81, 0x97, 0x62, 0x93, 0xf0, 0x71, 0x71, 0x60, 0x85, 0x94, 0x01, 0x29,
    /* bank # 11 */
    0x51, 0x79, 0x90, 0xa5, 0xf1, 0x28, 0x4c, 0x6c, 0x87, 0x0c, 0x95, 0x18, 0x85, 0x78, 0xa3, 0x83,
    0x90, 0x28, 0x4c, 0x6c, 0x88, 0x6c, 0xd8, 0xf3, 0xa2, 0x82, 0x00, 0xf2, 0x10, 0xa8, 0x92, 0x19,
    0x80, 0xa2, 0xf2, 0xd9, 0x26, 0xd8, 0xf1, 0x88, 0xa8, 0x4d, 0xd9, 0x48, 0xd8, 0x96, 0xa8, 0x39,
    0x80, 0xd9, 0x3c, 0xd8, 0x95, 0x80, 0xa8, 0x39, 0xa6, 0x86, 0x98, 0xd9, 0x2c, 0xda, 0x87, 0xa7,
    0x2c, 0xd8, 0xa8, 0x89, 0x95, 0x19, 0xa9, 0x80, 0xd9, 0x38, 0xd8, 0xa8, 0x89, 0x39, 0xa9, 0x80,
    0xda, 0x3c, 0xd8, 0xa8, 0x2e, 0xa8, 0x39, 0x90, 0xd9, 0x0c, 0xd8, 0xa8, 0x95, 0x31, 0x98, 0xd9,
    0x0c, 0xd8, 0xa8, 0x09, 0xd9, 0xff, 0xd8, 0x01, 0xda, 0xff, 0xd8, 0x95, 0x39, 0xa9, 0xda, 0x26,
    0xff, 0xd8, 0x90, 0xa8, 0x0d, 0x89, 0x99, 0xa8, 0x10, 0x80, 0x98, 0x21, 0xda, 0x2e, 0xd8, 0x89,
    0x99, 0xa8, 0x31, 0x80, 0xda, 0x2e, 0xd8, 0xa8, 0x86, 0x96, 0x31, 0x80, 0xda, 0x2e, 0xd8, 0xa8,
    0x87, 0x31, 0x80, 0xda, 0x2e, 0xd8, 0xa8, 0x82, 0x92, 0xf3, 0x41, 0x80, 0xf1, 0xd9, 0x2e, 0xd8,
    0xa8, 0x82, 0xf3, 0x19, 0x80, 0xf1, 0xd9, 0x2e, 0xd8, 0x82, 0xac, 0xf3, 0xc0, 0xa2, 0x80, 0x22,
    0xf1, 0xa6, 0x2e, 0xa7, 0x2e, 0xa9, 0x22, 0x98, 0xa8, 0x29, 0xda, 0xac, 0xde, 0xff, 0xd8, 0xa2,
    0xf2, 0x2a, 0xf1, 0xa9, 0x2e, 0x82, 0x92, 0xa8, 0xf2, 0x31, 0x80, 0xa6, 0x96, 0xf1, 0xd9, 0x00,
    0xac, 0x8c, 0x9c, 0x0c, 0x30, 0xac, 0xde, 0xd0, 0xde, 0xff, 0xd8, 0x8c, 0x9c, 0xac, 0xd0, 0x10,
    0xac, 0xde, 0x80, 0x92, 0xa2, 0xf2, 0x4c, 0x82, 0xa8, 0xf1, 0xca, 0xf2, 0x35, 0xf1, 0x96, 0x88,
    0xa6, 0xd9, 0x00, 0xd8, 0xf1, 0xff
};

uint16_t startAddress = 0x0400;
#define DMP_SAMPLE_RATE     (200)
#define GYRO_SF             (46850825LL * 200 / DMP_SAMPLE_RATE)


void MPU_LoadFirmware(uint8_t *firmware, uint16_t size, uint16_t start_addr) {
    uint16_t i = 0;
    uint16_t this_write = 0;
#define LOAD_CHUNK  (16)
    uint8_t cur[LOAD_CHUNK];
   
    for (i = 0; i < size; i += this_write) {
        this_write = min(LOAD_CHUNK, size - i);
        MPU_MemWrite(i, (uint8_t *)&firmware[i], this_write);
        MPU_MemRead(i, cur, this_write);
        if (memcmp(&firmware[i], cur, this_write)) {
            // @TODO: signalize about error
            this_write = 0xff;
        }
        
    }
    cur[0] = (uint8_t)(start_addr >> 8);
    cur[1] = (uint8_t)(start_addr & 0xff);
    MPU_MemWrite(PRGM_START_H, cur, 2);
}

void DMP_EnableGyroCal(uint8_t enable) {
    if (enable) {
        uint8_t regs[9] = {0xb8, 0xaa, 0xb3, 0x8d, 0xb4, 0x98, 0x0d, 0x35, 0x5d};
        MPU_MemWrite(CFG_MOTION_BIAS, regs, 9);
    } else {
        uint8_t regs[9] = {0xb8, 0xaa, 0xaa, 0xaa, 0xb0, 0x88, 0xc3, 0xc5, 0xc7};
        MPU_MemWrite(CFG_MOTION_BIAS, regs, 9);
    }
}

void DMP_EnableFeature(uint16_t features) {
    uint8_t tmp[10];
    
    /* Set integration scale factor. */
    tmp[0] = (uint8_t)((GYRO_SF >> 24) & 0xFF);
    tmp[1] = (uint8_t)((GYRO_SF >> 16) & 0xFF);
    tmp[2] = (uint8_t)((GYRO_SF >> 8) & 0xFF);
    tmp[3] = (uint8_t)(GYRO_SF & 0xFF);
    MPU_MemWrite(D_0_104, tmp, 4);
    
    /* Send sensor data to the FIFO. */
    tmp[0] = 0xA3;
    if (features & DMP_FEATURE_SEND_RAW_ACCEL) {
        tmp[1] = 0xC0;
        tmp[2] = 0xC8;
        tmp[3] = 0xC2;
    } else {
        tmp[1] = 0xA3;
        tmp[2] = 0xA3;
        tmp[3] = 0xA3;
    }
    if (features & DMP_FEATURE_SEND_ANY_GYRO) {
        tmp[4] = 0xC4;
        tmp[5] = 0xCC;
        tmp[6] = 0xC6;
    } else {
        tmp[4] = 0xA3;
        tmp[5] = 0xA3;
        tmp[6] = 0xA3;
    }
    tmp[7] = 0xA3;
    tmp[8] = 0xA3;
    tmp[9] = 0xA3;
    MPU_MemWrite(CFG_15, tmp, 10);
    
    /* Send gesture data to the FIFO. */
    if (features & (DMP_FEATURE_TAP | DMP_FEATURE_ANDROID_ORIENT)) {
        tmp[0] = DINA20;
    } else {
        tmp[0] = 0xD8;
    }
    MPU_MemWrite(CFG_27, tmp, 1);
    
    if (features & DMP_FEATURE_GYRO_CAL) {
        DMP_EnableGyroCal(1);
    } else {
        DMP_EnableGyroCal(0);
    }
    
    if (features & DMP_FEATURE_SEND_ANY_GYRO) {
        if (features & DMP_FEATURE_SEND_CAL_GYRO) {
            tmp[0] = 0xB2;
            tmp[1] = 0x8B;
            tmp[2] = 0xB6;
            tmp[3] = 0x9B;
        } else {
            tmp[0] = DINAC0;
            tmp[1] = DINA80;
            tmp[2] = DINAC2;
            tmp[3] = DINA90;
        }
        MPU_MemWrite(CFG_GYRO_RAW_DATA, tmp, 4);
    }
    
    if (features & DMP_FEATURE_TAP) {
        /* Enable tap. */
        tmp[0] = 0xF8;
        MPU_MemWrite(CFG_20, tmp, 1);
//        dmp_set_tap_thresh(TAP_XYZ, 250);
//        dmp_set_tap_axes(TAP_XYZ);
//        dmp_set_tap_count(1);
//        dmp_set_tap_time(100);
//        dmp_set_tap_time_multi(500);

//        dmp_set_shake_reject_thresh(GYRO_SF, 200);
//        dmp_set_shake_reject_time(40);
//        dmp_set_shake_reject_timeout(10);
    } else {
        tmp[0] = 0xD8;
        MPU_MemWrite(CFG_20, tmp, 1);
    }
    
    if (features & DMP_FEATURE_ANDROID_ORIENT) {
        tmp[0] = 0xD9;
    } else
        tmp[0] = 0xD8;
    MPU_MemWrite(CFG_ANDROID_ORIENT_INT, tmp, 1);
    
    if (features & DMP_FEATURE_LP_QUAT) {
        DMP_Enable_LP_QUAT(1);
    } else {
        DMP_Enable_LP_QUAT(0);
    }

    if (features & DMP_FEATURE_6X_LP_QUAT) {
        DMP_Enable_6X_LP_QUAT(1);
    } else {
        DMP_Enable_6X_LP_QUAT(0);
    }
    /* Pedometer is always enabled. */
//    dmp.feature_mask = mask | DMP_FEATURE_PEDOMETER;
    MPU_ResetFIFO();
    
//    dmp.packet_length = 0;
//    if (mask & DMP_FEATURE_SEND_RAW_ACCEL)
//        dmp.packet_length += 6;
//    if (mask & DMP_FEATURE_SEND_ANY_GYRO)
//        dmp.packet_length += 6;
//    if (mask & (DMP_FEATURE_LP_QUAT | DMP_FEATURE_6X_LP_QUAT))
//        dmp.packet_length += 16;
//    if (mask & (DMP_FEATURE_TAP | DMP_FEATURE_ANDROID_ORIENT))
//        dmp.packet_length += 4;
}

void DMP_Enable_LP_QUAT(uint8_t enable) {
    unsigned char regs[4];
    if (enable) {
        regs[0] = DINBC0;
        regs[1] = DINBC2;
        regs[2] = DINBC4;
        regs[3] = DINBC6;
    }
    else
        memset(regs, 0x8B, 4);

    MPU_MemWrite(CFG_LP_QUAT, regs, 4);

    MPU_ResetFIFO();
}

void DMP_Enable_6X_LP_QUAT(uint8_t enable)
{
    unsigned char regs[4];
    if (enable) {
        regs[0] = DINA20;
        regs[1] = DINA28;
        regs[2] = DINA30;
        regs[3] = DINA38;
    } else
        memset(regs, 0xA3, 4);

    MPU_MemWrite(CFG_8, regs, 4);

    MPU_ResetFIFO();
}

void DMP_SetFIFORate(uint16_t rate) {
    uint8_t regs_end[12] = {DINAFE, DINAF2, DINAAB,
        0xc4, DINAAA, DINAF1, DINADF, DINADF, 0xBB, 0xAF, DINADF, DINADF};
    uint16_t div;
    uint8_t tmp[2];

    div = DMP_SAMPLE_RATE / rate - 1;
    tmp[0] = (uint8_t)(div >> 8);
    tmp[1] = (uint8_t)(div & 0xff);
    MPU_MemWrite(D_0_22, tmp, 2);

    MPU_MemWrite(CFG_6, regs_end, 12);
}

//void MPU_ResetFIFO() {
//    MPU_WriteByte(INT_ENABLE, 0x00);        // no interrupts
//    MPU_WriteByte(FIFO_EN, 0x00);           // no records to fifo
//    MPU_WriteByte(USER_CTRL, 0x00);         // everything disabled

//    if (dmp_on) {
//        MPU_WriteByte(USER_CTRL, 0x0c);     // reset dmp and fifo
//        Delay_ms(50);
//        MPU_WriteByte(USER_CTRL, 0xe0);     // enable dmp, fifo and magnetometer
//        MPU_WriteByte(INT_ENABLE, 0x20);    // enable dmp interrupt
//        MPU_WriteByte(FIFO_EN, 0x00);       // no sensors write to fifo
//    } else {
//        MPU_WriteByte(USER_CTRL, 0x04);     // reset fifo
//        MPU_WriteByte(USER_CTRL, 0x40);     // enable fifo and magnetometer
//        Delay_ms(50);
//        MPU_WriteByte(INT_ENABLE, 0x01);    // enable data ready interrupt
//        MPU_WriteByte(FIFO_EN, 0x00);       // no sensors write to fifo
//    }
//}

//void MPU_SetIntEnable(uint8_t enable) {
////    unsigned char tmp;

//    if (dmp_on) {
//        if (enable) {
//            MPU_WriteByte(INT_ENABLE, 0x20); // enable dmp interrupt
//        } else {
//            MPU_WriteByte(INT_ENABLE, 0x00); // disable all interupts
//        }
//    } else {
//        if (enable) {
//            MPU_WriteByte(INT_ENABLE, 0x01);    // enable data ready interrupt
//        } else {
//            MPU_WriteByte(INT_ENABLE, 0x00); // disable all interupts
//        }
//    }
//}

void MPU_SetDMPState(uint8_t enable)
{
//    unsigned char tmp;
    if (dmp_on == enable)
        return;

    if (enable) {
        /* Disable data ready interrupt. */
        MPU_SetIntEnable(0);
        /* Disable bypass mode. */
        //mpu_set_bypass(0);
        /* Keep constant sample rate, FIFO rate controlled by DMP. */
        //mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
        /* Remove FIFO elements. */
//        tmp = 0;
        
        dmp_on = 1;
        /* Enable DMP interrupt. */
        MPU_SetIntEnable(1);
        MPU_ResetFIFO();
    } else {
        /* Disable DMP interrupt. */
        MPU_SetIntEnable(0);
        /* Restore FIFO settings. */
        MPU_WriteByte(FIFO_EN, 0x00);
        dmp_on = 0;
        MPU_ResetFIFO();
    }
}
